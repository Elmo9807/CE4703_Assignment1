=====================================
CE4703 Assignment 1 Report
=====================================

Student ID: 17238811
Author: Dylan O'Halloran
Start Date: 10/10/2025
Purpose: Document the following - List Of Modules, List of Functions Per Module, Specification for Each Function, Pseudocode for Each Function

=====================================
Section 1: Module Structure
=====================================

Module 1: config.h (Preprocessor Configuration)
   Purpose: Define macros and constants used throughout the program
   Files: config.h (header only)
   Macros:
      - UNUSED_MARKER: Simple macro for marking unused array elements
      - MAX(a, b): Macro with parameters to find the maximum of two given values
      - MIN(a, b): Macro with parameters to find the minimum of two given values

Module 2: utility
   Purpose: Utility functions for general use
   Files: utility.h, utility.c
   Functions:
      - int generateRandomNumber(int lowerLimit, int upperLimit);

Module 3: array_manipulation
   Purpose: Functions for modifying array contents
   Files: array_manipulation.h, array_manipulation.c
   Functions:
      - void clearArray(int arr[], int capacity);
      - void fillArrayRandom(int arr[], int size, int capacity, int min, int max);
      - void sortArray(int arr[], int capacity);
      - void randomiseArray(int arr[], int capacity);

Module 4: array_io
   Purpose: Functions for input/output of arrays
   Files: array_io.h, array_io.c
   Functions:
      - void fillFromKeyboard(int arr[], int capacity);
      - void printUsed(int arr[], int capacity);
      - void printAll(int arr[], int capacity);

Module 5: array_statistics
   Purpose: Statistical analysis functions for arrays
   Files: array_statistics.h, array_statistics.c
   Functions:
      - int getMinimum(int arr[], int capacity);
      - int getMaximum(int arr[], int capacity);
      - double getAverage(int arr[], int capacity);
      - double getMedian(int arr[], int capacity);
      - double getVariance(int arr[], int capacity);
      - double getStandardDeviation(int arr[], int capacity);
      - int countUsedElements(int arr[], int capacity);

Module 6: menu
   Purpose: Menu functions that demonstrate array operations
   Files: menu.h, menu.c
   Functions:
      - void menuFunction1(void);
      - void menuFunction2(void);
      - void menuFunction3(void);

Module 7: main
   Purpose: Program entry point
   Files: main.c
   Functions:
      - int main(int argc, char *argv[]);

=====================================
Section 2: Function Specifications
=====================================

WF1: generateRandomNumber()

Function Prototype:
   int generateRandomNumber(int lowerLimit, int upperLimit);

Specification:
   Purpose:
      Generate a random integer within specified bounds (incl.).

   Input:
        - lowerLimit: integer, minimum value (incl.)
        - upperLimit: integer, maximum value (incl.)
        - Constraint: lowerLimit <= upperLimit

    Output:
        - Returns: Random integer in range [lowerLimit, upperLimit]

    Behaviour:
        - Generates uniformly distributed random integer
        - Seeds random number generator on first call
        - Both bounds are inclusive

WF2: fillFromKeyboard()

Function Prototype:
   void fillFromKeyboard(int arr[], int capacity);   

Specification:
   Purpose:
        - Allow user to input positive integer values into an array in sequence

   Input:
        - arr: An array of integers to be filled by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0

    Output:
        - Returns: Void

    Behaviour:
        - Prompt user to enter integer values in sequence
        - Store the value in the next available array position, continue these operations until capacity is met
        - If a user enters a negative number, terminate input and set unfilled elements of the array to UNUSED_MARKER
        - Function will disallow user from entering values beyond capacity

WF3: fillArrayRandom()

Function Prototype:
    void fillArrayRandom(int arr[], int size, int capacity, int min, int max)

Specification:
    Purpose:
        - Fill an array of integers of randomised values between range min-max inclusive, to capacity

    Input:
        - arr: An array of integers to be filled by the function
        - capacity: Maximum number of elements in the array
        - min: lowest possible value in the range
        - max: highest possible value in the range
        - size: the amount of random numbers to add
        - Constraints: capacity > 0

    Output:
        - Returns: Void

    Behaviour:
        - Generate random number in range by calling WF1
        - Store the value in the next available array position until size is met
        - When size is met, if unfilled elements remain, fill with UNUSED_MARKER

WF4: clearArray()

Function Prototype:
    void clearArray(int arr[], int capacity)

Specification:
    Purpose:
        - Clear an array of integers by "removing" all elements, that is to fill the array with the unused value.

    Input:
        - arr: An array of integers to be cleared by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void

    Behaviour:
        - Receive an array of integers and its capacity
        - Iterate through the array, setting each value to the unused marker value
        - When capacity-1 is met, return to caller

WF5: sortArray()

Function Prototype:
    void sortArray(int arr[], int capacity)

Specification:
    Purpose:
        - Sort an array of integers in ascending order, leaving all unused elements at the end of the array

    Input:
        - arr: An array of integers to be cleared by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void

    Behaviour:
        - Receive an array of integers and its capacity
        - Iterate through the array up to capacity-1, find number of used elements
        - Iterate through array again up to used-1, using bubble sort algorithm to sort in ascending order
        - When used-1 is met, return to caller

WF6: randomiseArray()

Function Prototype:
    void randomiseArray(int arr[], int capacity)

Specification:
    Purpose:
        - Randomise an array of integers with a given capacity, leaving all unused elements at the end of the array

    Input:
        - arr: An array of integers to be cleared by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void

    Behaviour:
        - Receive an array of integers and its capacity
        - Iterate through the array up to capacity-1, find number of used elements
        - Iterate through array again up to used-1, using randomised sorting algorithm to sort
        - When used-1 is met, return to caller

WF7: printUsed()

Function Prototype:
    void printUsed(int arr[], int capacity)

Specification:
    Purpose:
        - Print each used element of an array

    Input:
        - arr: An array of integers to be cleared by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void
      
    Behaviour:
        - Receive an array of integers and its capacity
        - Print opening brace
        - Iterate through the array up to capacity-1, printing each used element
        - Print closing brace

WF8: printAll()

Function Prototype:
    void printAll(int arr[], int capacity)

Specification:
    Purpose:
        - Print each element of an array

    Input:
        - arr: An array of integers to be printed by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void

    Behaviour:
        - Receive an array of integers and its capacity
        - Print opening brace
        - Iterate through the array up to capacity-1, printing each element
        - Print closing brace

WF10: int getMaximum(int arr[], int capacity);

Function Prototype:
   int getMaximum(int arr[], int capacity);

Specification:
   Purpose:
        - Find and return the maximum value among the used elements in an array

   Input:
        - arr: An array of integers to be analyzed by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0, array must contain at least one used element

   Output:
        - Returns: Integer value representing the maximum used element in the array

   Behaviour:
        - Receive an array of integers and its capacity
        - Initialize maximum to the first element in the array
        - Iterate through the array, comparing each used element with current maximum
        - Skip UNUSED_MARKER values (since they appear at end of array)
        - Update maximum value when smaller element is found using MIN macro
        - When UNUSED_MARKER is encountered or capacity-1 is reached, return maximum value to caller

WF11: double getAverage()

Function Prototype:
    double getAverage(int arr[], int capcity)

Specification:
    Purpose:
        - Find and return the maximum value among the used elements in an array

    Input:
        - arr: An array of integers to be analyzed by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0, array must contain at least one used element

    Output:
        - Returns: Integer value representing the maximum used element in the array

    Behaviour:
        - Receive an array of integers and its capacity
        - Initialise maximum to the first element in the array
        - Iterate through the array, comparing each used element with current maximum
        - Skip UNUSED_MARKER values (terminate iteration when encountered)
        - Update maximum value when larger element is found using MAX macro
        - When UNUSED_MARKER is encountered or capacity is exhausted, return maximum value to caller

WF12: double getMedian()

Function Prototype:
   double getMedian(int arr[], int capacity);

Specification:
   Purpose:
        - Find and return the median value of the used elements in an array

   Input:
        - arr: An array of integers to be analysed by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0, array must contain at least one used element

   Output:
        - Returns: Double value representing the median of used elements
        - If odd number of elements: returns the middle value
        - If even number of elements: returns average of two middle values
        - Returns 0.0 if memory allocation fails

   Behaviour:
        - Receive an array of integers and its capacity
        - Count the number of used elements in the array
        - Dynamically allocate memory for a temporary array
        - Verify memory allocation succeeded
        - Sort the temporary array in ascending order using Bubblesort
        - Calculate median based on whether count is odd or even
        - Free dynamically allocated memory
        - Return median value to caller

=====================================
Section 3: Pseudocode
=====================================

WF1: generateRandomNumber(lowerLimit, upperLimit)

First Refinement:
1. Initialise random number generator if not already seeded
2. Calculate range of possible values
3. Generate and return random number in range

Second Refinement:
1. Initialise random number generator if not already seeded
   1.1 Use static flag to track seeding status
   1.2 If not seeded:
      1.2.1 Call srand() with current time
      1.2.2 Set flag to true

2. Calculate range of possible values
   2.1 range = upperLimit - lowerLimit + 1

3. Generate and return random number in range
   3.1 Generate random value using rand()
   3.2 Apply modulo to constrain: rand() % range
   3.3 Shift to correct bounds: lowerLimit + result
   3.4 Return final value

WF2: fillFromKeyboard()

First Refinement:
1. Read in and assign user generated values from the keyboard to the desired structure
2. Terminate input stream and fill remaining slots with -1

Second Refinement:
1. Read in the user generated values from the keyboard:
   1.1 Printf a statement to the user prompting them for keyboard input
   1.2 Begin a for loop at index 0, terminating at capacity-1, with a step of 1
   1.3 Using these for loop parameters, read and assign values to index[i]
   1.4 If value is negative, jump to step 2, else continue
   1.5 Once i = capacity-1, return to caller

2. Terminate input stream and fill remaining slots with -1
   2.1 Terminate input and begin new loop
   2.2 New loop initialised at current i value, iterate until capacity-1, filling array with UNUSED_MARKER value
   2.3 Once new iterator value = capacity-1, return to caller

WF3: fillArrayRandom()

First Refinement:
1. Generate a random number between ranges of min and max
2. Terminate random number generation and fill remaining slots with UNUSED_MARKER

Second Refinement:
1. Generate a random number between ranges of min and max
    1.1 Initialise iterator value i
    1.2 Begin a for loop at index 0, i < size AND i < capacity, with a step of 1, when I >= size, we move to step 2
    1.3 Call function generateRandomNumber with parameters (min, max)
    1.4 Store the generated value at arr[i]

2. Terminate random number generation and fill remaining slots with -1
    2.1 Move to next for loop, using previous iterator value as starting point, capacity-1 as our termination, with a step of 1
    2.2 Iterate through the remaining elements of the array, assigning UNUSED_MARKER to every available position
    2.3 Terminate loop and return to caller

WF4: clearArray()

First Refinement:
1. Receive array and capacity as parameters
2. Iterate through each index from 0 to capacity - 1
3. Replace the value at each index with UNUSED_MARKER
4. When capacity-1 is met, return to caller

WF5: sortArray()

First Refinement:
1. Receive array and capacity as parameters
2. Iterate through each index from 0 to capacity - 1
3. Iterate through each index again from 0 to used - 1
4. When used-1 is met, return to caller

Second Refinement:
1. Receive array and capacity as parameters
    1.1 Initialise used as type int

2. Iterate through each index from 0 to capacity - 1
    2.1 Initialise for loop from index 0, run to capacity - 1, step of 1
    2.2 At each index, compare element with UNUSED_MARKER, if the element is unused, break, else move to 2.3
    2.3 Increment used value by 1

3. Iterate through each index again from iterator i = 0 to used - 1
    3.1 Iterate through each index from iterator j = 0 to used - i - 1, step of 1
    3.2 Compare arr[j] with arr[j+1], if arr[j] > arr[j+1] move to step 3.3, else continue
    3.3 Set temporary storage variable = arr[j], arr[j] = arr[j+1] and then arr[j+1] = temp

WF6: randomiseArray()

First Refinement:
1. Receive array and capacity as parameters
2. Iterate through each index from 0 to capacity - 1
3. Iterate through each index again from used -1 to 1

Second Refinement:

1. Receive array and capacity as parameters
    1.1 Initialise used as type int and set to 0

2. Iterate through each index from 0 to capacity - 1
    2.1 Initialise for loop from index 0, run to capacity - 1, step of 1
    2.2 At each index, compare element with UNUSED_MARKER, if element is unused, break, else move to 2.3
    2.3 Increment used value by 1

3. Iterate through each index again from used - 1 to 1, using Fisher-Yates shuffling algorithm
    3.1 Iterate for j from used - 1 down to 1 with step -1
        3.1.1 Generate randomIndex = randomNumberGenerator(0, j)
        3.1.2 Swap arr[j] with arr[randomIndex]
            - temp = arr[j]
            - arr[j] = arr[randomIndex]
            - arr[randomIndex] = temp

WF7: printUsed()

First Refinement:
1. Receive array and capacity as parameters
2. Print opening brace
3. Iterate through array and print used elements with commas
4. Print closing brace

Second Refinement: 

1. Receive array and capacity as parameters

2. Print opening brace
    2.1 Output the character '{'

3. Iterate through array and print used elements with commas
    3.1 Initialise first as type int with value of 1
    3.2 Iterate for i from index 0 to capacity - 1, with a step of 1
    3.3 For each element:
        2.3.1 If element equals UNUSED_MARKER, break from loop
        2.3.2 If not first element, print comma and space
        2.3.3 Print the element value
        2.3.4 Set flag 'first' to 0

4. Print closing brace
    4.1 Output character '}'
    4.2 Output newline character

WF8: printAll()

First Refinement:
1. Receive array and its capacity as parameters
2. Print opening brace
3. Iterate through array and print each value
4. Print closing brace

Second Refinement:

1. Receive array and its capacity as parameters

2. Print opening brace:
    2.1 Output character '{'

3. Iterate through array and print each value
    3.1 Initialise first with type int with a value of 1
    3.2 Iterate for i from index 0 to capacity - 1, with a step of 1
    3.3 For each element
        3.3.1 If not first element, print comma and space
        3.3.2 Print element value
        3.3.3 Set flag 'first' to 0

4. Print closing brace
    4.1 Output character '}'
    4.2 Output newline character

WF9: getMinimum()

First Refinement:
1. Initialise minimum value to first array element
2. Iterate through array comparing each used element with current minimum
3. Return the minimum value found

Second Refinement:
1. Initialise minimum value to first array element
    1.1 Set minimum = arr[0]

2. Iterate through array comparing each used element with current minimum
    2.1 Initialise for loop from index 0, run to capacity - 1, step of 1
    2.2 At each index, check if arr[i] equals UNUSED_MARKER
    2.3 If arr[i] is UNUSED_MARKER, break from loop (unused elements are at end)
    2.4 Otherwise, use MIN macro to compare: minimum = MIN(minimum, arr[i])
    2.5 Continue until break condition or i reaches capacity - 1

3. Return the minimum value found
    3.1 Return minimum to caller

WF10: getMaximum()

First Refinement:
1. Initialise maximum value to first array element
2. Iterate through array comparing each used element with current maximum
3. Return the maximum value found

Second Refinement:
1. Initialise maximum value to first array element
    1.1 Set maximum = arr[0]

2. Iterate through array comparing each used element with current maximum
    2.1 Initialise for loop from index 0, run to capacity - 1, step of 1
    2.2 At each index, check if arr[i] equals UNUSED_MARKER
    2.3 If arr[i] is UNUSED_MARKER, break from loop (unused elements are at end)
    2.4 Otherwise, use MAX macro to compare: maximum = MAX(maximum, arr[i])
    2.5 Continue until break condition or i reaches capacity - 1

3. Return the maximum value found
    3.1 Return maximum to caller

WF11: getAverage()

First Refinement:
1. Initialise divisor and total to zero
2. Iterate through array summing used elements and counting them
3. Calculate and return the average as a double

Second Refinement:
1. Initialise divisor and total to zero
    1.1 Set divisor = 0
    1.2 Set total = 0

2. Iterate through array summing used elements and counting them
    2.1 Initialise for loop from index 0, run to capacity - 1, step of 1
    2.2 At each index, check if arr[i] equals UNUSED_MARKER
    2.3 If arr[i] is UNUSED_MARKER, break from loop (unused elements are at end)
    2.4 Otherwise, add arr[i] to total: total = total + arr[i]
    2.5 Increment divisor: divisor = divisor + 1
    2.6 Continue until break condition or i reaches capacity - 1

3. Calculate and return the average as a double
    3.1 If divisor equals 0, return 0.0 (avoid division by zero)
    3.2 Cast total to double and divide by divisor
    3.3 Return (double)total / divisor to caller

WF12: getMedian()

First Refinement:
1. Count the number of used elements in the array
2. Dynamically allocate and populate a temporary sorted array
3. Calculate the median value
4. Free allocated memory and return median

Second Refinement:
1. Count the number of used elements in the array
    1.1 Initialise used = 0
    1.2 Initialise for loop from index 0 to capacity - 1, step of 1
    1.3 At each index, check if arr[i] equal UNUSED_MARKER
    1.4 If arr[i] is UNUSED_MARKER, break from loop
    1.5 Otherwise, increment used by 1

2. Dynamically allocate and populate a temporary sorted array
    2.1 Dynamically allocate memory: tempArr = malloc(used * sizeof(int))
    2.2 Check if allocation succeeded (tempArr != NULL)
        2.2.1 If tempArr is NULL, return 0.0
    2.3 Copy used elements from arr to tempArr
        2.3.1 Initialise for loop from i = 0 to used - 1, step of 1
        2.3.2 Set tempArr[i] = arr[i]
    2.4 Sort tempArr using bubble sort algorithm
        2.4.1 Initialise outer loop from i = 0 to used - 2, step of 1
        2.4.2 Initialise inner loop from j = 0 to used - i - 2, step of 1
        2.4.3 If tempArr[j] > tempArr[j+1], swap:
            2.4.3.1 temp = tempArr[j]
            2.4.3.2 tempArr[j] = tempArr[j+1]
            2.4.3.3 tempArr[j+1] = temp

3. Calculate the median value
    3.1 Calculate middle index: middle = used / 2
    3.2 Declare median as double
    3.3 If used is odd (used % 2 == 1):
        3.3.1 Return tempArr[middle] as double
    3.4 If used is even (used % 2 == 0):
        3.3.1 Calculate average of two middle values
        3.3.2 median = (tempArr[middle - 1] + tempArr[middle]) / 2.0

4. Free allocated memory and return the median
    4.1 Call free(tempArr) to release dynamically allocated memory
    4.2 Return median to caller