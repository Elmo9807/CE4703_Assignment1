=====================================
CE4703 Assignment 1 Report
=====================================

Student ID: 17238811
Author: Dylan O'Halloran
Start Date: 10/10/2025
Purpose: Document the following - List Of Modules, List of Functions Per Module, Specification for Each Function, Pseudocode for Each Function

=====================================
Section 1: Module Structure
=====================================

Module 1: config.h (Preprocessor Configuration)
   Purpose: Define macros and constants used throughout the program
   Files: config.h (header only)
   Macros:
      - UNUSED_MARKER: Simple macro for marking unused array elements
      - MAX(a, b): Macro with parameters to find the maximum of two given values
      - MIN(a, b): Macro with parameters to find the minimum of two given values

Module 2: utility
   Purpose: Utility functions for general use
   Files: utility.h, utility.c
   Functions:
      - int generateRandomNumber(int lowerLimit, int upperLimit);

Module 3: array_manipulation
   Purpose: Functions for modifying array contents
   Files: array_manipulation.h, array_manipulation.c
   Functions:
      - void clearArray(int arr[], int capacity);
      - void fillArrayRandom(int arr[], int size, int capacity, int min, int max);
      - void sortArray(int arr[], int capacity);
      - void randomiseArray(int arr[], int capacity);

Module 4: array_io
   Purpose: Functions for input/output of arrays
   Files: array_io.h, array_io.c
   Functions:
      - void fillFromKeyboard(int arr[], int capacity);
      - void printUsed(int arr[], int capacity);
      - void printAll(int arr[], int capacity);

Module 5: array_statistics
   Purpose: Statistical analysis functions for arrays
   Files: array_statistics.h, array_statistics.c
   Functions:
      - int getMinimum(int arr[], int capacity);
      - int getMaximum(int arr[], int capacity);
      - double getAverage(int arr[], int capacity);
      - double getMedian(int arr[], int capacity);
      - double getVariance(int arr[], int capacity);
      - double getStandardDeviation(int arr[], int capacity);
      - int countUsedElements(int arr[], int capacity);

Module 6: menu
   Purpose: Menu functions that demonstrate array operations
   Files: menu.h, menu.c
   Functions:
      - void menuFunction1(void);
      - void menuFunction2(void);
      - void menuFunction3(void);

Module 7: main
   Purpose: Program entry point
   Files: main.c
   Functions:
      - int main(int argc, char *argv[]);

=====================================
Section 2: Function Specifications
=====================================

WF1: generateRandomNumber()

Function Prototype:
   int generateRandomNumber(int lowerLimit, int upperLimit);

Specification:
   Purpose:
      Generate a random integer within specified bounds (incl.).

   Input:
        - lowerLimit: integer, minimum value (incl.)
        - upperLimit: integer, maximum value (incl.)
        - Constraint: lowerLimit <= upperLimit

    Output:
        - Returns: Random integer in range [lowerLimit, upperLimit]

    Behaviour:
        - Generates uniformly distributed random integer
        - Seeds random number generator on first call
        - Both bounds are inclusive

WF2: fillFromKeyboard()

Function Prototype:
   void fillFromKeyboard(int arr[], int capacity);   

Specification:
   Purpose:
        - Allow user to input positive integer values into an array in sequence

   Input:
        - arr: An array of integers to be filled by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0

    Output:
        - Returns: Void

    Behaviour:
        - Prompt user to enter integer values in sequence
        - Store the value in the next available array position, continue these operations until capacity is met
        - If a user enters a negative number, terminate input and set unfilled elements of the array to UNUSED_MARKER
        - Function will disallow user from entering values beyond capacity

WF3: fillArrayRandom()

Function Prototype:
    void fillArrayRandom(int arr[], int size, int capacity, int min, int max)

Specification:
    Purpose:
        - Fill an array of integers of randomised values between range min-max inclusive, to capacity

    Input:
        - arr: An array of integers to be filled by the function
        - capacity: Maximum number of elements in the array
        - min: lowest possible value in the range
        - max: highest possible value in the range
        - size: the amount of random numbers to add
        - Constraints: capacity > 0

    Output:
        - Returns: Void

    Behaviour:
        - Generate random number in range by calling WF1
        - Store the value in the next available array position until size is met
        - When size is met, if unfilled elements remain, fill with UNUSED_MARKER

WF4: clearArray()

Function Prototype:
    void clearArray(int arr[], int capacity)

Specification:
    Purpose:
        - Clear an array of integers by "removing" all elements, that is to fill the array with the unused value.

    Input:
        - arr: An array of integers to be cleared by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void

    Behaviour:
        - Receive an array of integers and its capacity
        - Iterate through the array, setting each value to the unused marker value
        - When capacity-1 is met, return to caller

WF5: sortArray()

Function Prototype:
    void sortArray(int arr[], int capacity)

Specification:
    Purpose:
        - Sort an array of integers in ascending order, leaving all unused elements at the end of the array

    Input:
        - arr: An array of integers to be cleared by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void

    Behaviour:
        - Receive an array of integers and its capacity
        - Iterate through the array up to capacity-1, find number of used elements
        - Iterate through array again up to used-1, using bubble sort algorithm to sort in ascending order
        - When used-1 is met, return to caller

WF6: randomiseArray()

Function Prototype:
    void randomiseArray(int arr[], int capacity)

Specification:
    Purpose:
        - Randomise an array of integers with a given capacity, leaving all unused elements at the end of the array

    Input:
        - arr: An array of integers to be cleared by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void

    Behaviour:
        - Receive an array of integers and its capacity
        - Iterate through the array up to capacity-1, find number of used elements
        - Iterate through array again up to used-1, using randomised sorting algorithm to sort
        - When used-1 is met, return to caller

WF7: printUsed()

Function Prototype:
    void printUsed(int arr[], int capacity)

Specification:
    Purpose:
        - Print each used element of an array

    Input:
        - arr: An array of integers to be cleared by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void
      
    Behaviour:
        - Receive an array of integers and its capacity
        - Print opening brace
        - Iterate through the array up to capacity-1, printing each used element
        - Print closing brace

WF8: printAll()

Function Prototype:
    void printAll(int arr[], int capacity)

Specification:
    Purpose:
        - Print each element of an array

    Input:
        - arr: An array of integers to be printed by the function
        - capacity: Maximum number of elements in the array

    Output:
        - Returns: Void

    Behaviour:
        - Receive an array of integers and its capacity
        - Print opening brace
        - Iterate through the array up to capacity-1, printing each element
        - Print closing brace

WF10: int getMaximum(int arr[], int capacity);

Function Prototype:
   int getMaximum(int arr[], int capacity);

Specification:
   Purpose:
        - Find and return the maximum value among the used elements in an array

   Input:
        - arr: An array of integers to be analysed by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0, array must contain at least one used element

   Output:
        - Returns: Integer value representing the maximum used element in the array

   Behaviour:
        - Receive an array of integers and its capacity
        - Initialise maximum to the first element in the array
        - Iterate through the array, comparing each used element with current maximum
        - Skip UNUSED_MARKER values (since they appear at end of array)
        - Update maximum value when smaller element is found using MIN macro
        - When UNUSED_MARKER is encountered or capacity-1 is reached, return maximum value to caller

WF11: double getAverage()

Function Prototype:
    double getAverage(int arr[], int capcity)

Specification:
    Purpose:
        - Find and return the maximum value among the used elements in an array

    Input:
        - arr: An array of integers to be analysed by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0, array must contain at least one used element

    Output:
        - Returns: Integer value representing the maximum used element in the array

    Behaviour:
        - Receive an array of integers and its capacity
        - Initialise maximum to the first element in the array
        - Iterate through the array, comparing each used element with current maximum
        - Skip UNUSED_MARKER values (terminate iteration when encountered)
        - Update maximum value when larger element is found using MAX macro
        - When UNUSED_MARKER is encountered or capacity is exhausted, return maximum value to caller

WF12: double getMedian()

Function Prototype:
   double getMedian(int arr[], int capacity);

Specification:
   Purpose:
        - Find and return the median value of the used elements in an array

   Input:
        - arr: An array of integers to be analysed by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0, array must contain at least one used element

   Output:
        - Returns: Double value representing the median of used elements
        - If odd number of elements: returns the middle value
        - If even number of elements: returns average of two middle values
        - Returns 0.0 if memory allocation fails

   Behaviour:
        - Receive an array of integers and its capacity
        - Count the number of used elements in the array
        - Dynamically allocate memory for a temporary array
        - Verify memory allocation succeeded
        - Sort the temporary array in ascending order using Bubblesort
        - Calculate median based on whether count is odd or even
        - Free dynamically allocated memory
        - Return median value to caller

WF13: double getVariance()

Function Prototype:
    double getVariance(int arr[], int capacity);

Specification:
    Purpose:
        - Find and return the variance of the used elements in the array

    Input:
        - arr: An array of integers to be analysed by the function
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0, array must contain at least one used element

    Output:
        - Returns: Double value representing variance value of used elements
        - Returns 0.0 if array is empty

    Behaviour:
        - Receive an array of integers and its capacity
        - Count the number of used elements in the array
        - Calculate the average of used elements
        - Calculate variance
        - Return variance

WF14: getStandardDeviation()

Function Prototype:
    double getStandardDeviation(int arr[], int capacity);

Specification:
    Purpose:
        - Calculate and return the standard deviation of used elements in an integer array.

    Input:
        - arr: An array of integers
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0
    
    Output:
        - Returns: Standard deviation as a double
        - Returns 0.0 if no used elements exist

    Behaviour:
        - Call getVariance() to compute array variance
        - Calculate square root of variance to get standard deviation
        - Return the result
        - Only considers elements that are not equal to UNUSED_MARKER

WF15: countUsedElements()

Function Prototype:
    int countUsedElements(int arr[], int capacity);

Specification:
    Purpose: 
        - Count and return the number of used elements in an array.

    Input:
        - arr: An array of integers
        - capacity: Maximum number of elements in the array
        - Constraint: capacity > 0

    Output:
        - Returns: Integer representing the count of used elements
        - Returns 0 if no used elements exist

    Behaviour:
        - Iterate through array from index 0 to capacity -1
        - Count elements until UNUSED_MARKER is encountered
        - Return the count of used elements
        - Assumes unused elements are grouped at the end of the array

=====================================
Section 3: Pseudocode
=====================================

WF1: generateRandomNumber(lowerLimit, upperLimit)

First Refinement:
1. Initialise random number generator if not already seeded
2. Calculate range of possible values
3. Generate and return random number in range

Second Refinement:
1. Initialise random number generator if not already seeded
   1.1 Use static flag to track seeding status
   1.2 If not seeded:
      1.2.1 Call srand() with current time
      1.2.2 Set flag to true

2. Calculate range of possible values
   2.1 range = upperLimit - lowerLimit + 1

3. Generate and return random number in range
   3.1 Generate random value using rand()
   3.2 Apply modulo to constrain: rand() % range
   3.3 Shift to correct bounds: lowerLimit + result
   3.4 Return final value

WF2: fillFromKeyboard()

First Refinement:
1. Read in and assign user generated values from the keyboard to the desired structure
2. Terminate input stream and fill remaining slots with -1

Second Refinement:
1. Read in the user generated values from the keyboard:
   1.1 Printf a statement to the user prompting them for keyboard input
   1.2 Begin a for loop at index 0, terminating at capacity-1, with a step of 1
   1.3 Using these for loop parameters, read and assign values to index[i]
   1.4 If value is negative, jump to step 2, else continue
   1.5 Once i = capacity-1, return to caller

2. Terminate input stream and fill remaining slots with -1
   2.1 Terminate input and begin new loop
   2.2 New loop initialised at current i value, iterate until capacity-1, filling array with UNUSED_MARKER value
   2.3 Once new iterator value = capacity-1, return to caller

WF3: fillArrayRandom()

First Refinement:
1. Generate a random number between ranges of min and max
2. Terminate random number generation and fill remaining slots with UNUSED_MARKER

Second Refinement:
1. Generate a random number between ranges of min and max
    1.1 Initialise iterator value i
    1.2 Begin a for loop at index 0, i < size AND i < capacity, with a step of 1, when I >= size, we move to step 2
    1.3 Call function generateRandomNumber with parameters (min, max)
    1.4 Store the generated value at arr[i]

2. Terminate random number generation and fill remaining slots with -1
    2.1 Move to next for loop, using previous iterator value as starting point, capacity-1 as our termination, with a step of 1
    2.2 Iterate through the remaining elements of the array, assigning UNUSED_MARKER to every available position
    2.3 Terminate loop and return to caller

WF4: clearArray()

First Refinement:
1. Receive array and capacity as parameters
2. Iterate through each index from 0 to capacity - 1
3. Replace the value at each index with UNUSED_MARKER
4. When capacity-1 is met, return to caller

WF5: sortArray()

First Refinement:
1. Receive array and capacity as parameters
2. Count used elements using countUsedElements()
3. Sort used elements in ascending order using bubblesort
4. Return to caller

Second Refinement:

1. Receive array and capacity as parameters
    1.1 Count used elements using countUsedElements() function
    1.2 Store result in used variable

2. Sort used elements in ascending order using bubble sort
    2.1 Iterate through each index from iterator i = 0 to used - 1
    2.2 Iterate through each index from iterator j = 0 to used - i - 1, step of 1
    2.3 Compare arr[j] with arr[j+1], if arr[j] > arr[j+1] move to step 2.4, else continue
    2.4 Set temporary storage variable = arr[j], arr[j] = arr[j+1] and then arr[j+1] = temp

3. Return to caller

WF6: randomiseArray()

First Refinement:
1. Receive array and capacity as parameters
2. Count used elements using countUsedElements()
3. randomise used elements using Fisher-Yates shuffling algorithm

Second Refinement:

1. Receive array and capacity as parameters

2. Count used elements using countUsedElements() function
   2.2 Store result in used variable

3. randomise used elements using Fisher-Yates shuffling algorithm
   3.1 Iterate for j from used - 1 down to 1 with step -1
      3.1.1 Generate randomIndex = randomNumberGenerator(0, j)
      3.1.2 Swap arr[j] with arr[randomIndex]
         - temp = arr[j]
         - arr[j] = arr[randomIndex]
         - arr[randomIndex] = temp

WF7: printUsed()

First Refinement:
1. Receive array and capacity as parameters
2. Print opening brace
3. Iterate through array and print used elements with commas
4. Print closing brace

Second Refinement: 

1. Receive array and capacity as parameters

2. Print opening brace
    2.1 Output the character '{'

3. Iterate through array and print used elements with commas
    3.1 Initialise first as type int with value of 1
    3.2 Iterate for i from index 0 to capacity - 1, with a step of 1
    3.3 For each element:
        3.3.1 If element equals UNUSED_MARKER, break from loop
        3.3.2 If not first element, print comma and space
        3.3.3 Print the element value
        3.3.4 Set flag 'first' to 0

4. Print closing brace
    4.1 Output character '}'
    4.2 Output newline character

WF8: printAll()

First Refinement:
1. Receive array and its capacity as parameters
2. Print opening brace
3. Iterate through array and print each value
4. Print closing brace

Second Refinement:

1. Receive array and its capacity as parameters

2. Print opening brace:
    2.1 Output character '{'

3. Iterate through array and print each value
    3.1 Initialise first with type int with a value of 1
    3.2 Iterate for i from index 0 to capacity - 1, with a step of 1
    3.3 For each element
        3.3.1 If not first element, print comma and space
        3.3.2 Print element value
        3.3.3 Set flag 'first' to 0

4. Print closing brace
    4.1 Output character '}'
    4.2 Output newline character

WF9: getMinimum()

First Refinement:
1. Initialise minimum value to first array element
2. Iterate through array comparing each used element with current minimum
3. Return the minimum value found

Second Refinement:
1. Initialise minimum value to first array element
    1.1 Set minimum = arr[0]

2. Iterate through array comparing each used element with current minimum
    2.1 Initialise for loop from index 0, run to capacity - 1, step of 1
    2.2 At each index, check if arr[i] equals UNUSED_MARKER
    2.3 If arr[i] is UNUSED_MARKER, break from loop (unused elements are at end)
    2.4 Otherwise, use MIN macro to compare: minimum = MIN(minimum, arr[i])
    2.5 Continue until break condition or i reaches capacity - 1

3. Return the minimum value found
    3.1 Return minimum to caller

WF10: getMaximum()

First Refinement:
1. Initialise maximum value to first array element
2. Iterate through array comparing each used element with current maximum
3. Return the maximum value found

Second Refinement:
1. Initialise maximum value to first array element
    1.1 Set maximum = arr[0]

2. Iterate through array comparing each used element with current maximum
    2.1 Initialise for loop from index 0, run to capacity - 1, step of 1
    2.2 At each index, check if arr[i] equals UNUSED_MARKER
    2.3 If arr[i] is UNUSED_MARKER, break from loop (unused elements are at end)
    2.4 Otherwise, use MAX macro to compare: maximum = MAX(maximum, arr[i])
    2.5 Continue until break condition or i reaches capacity - 1

3. Return the maximum value found
    3.1 Return maximum to caller

WF11: getAverage()

First Refinement:
1. Initialise divisor and total to zero
2. Iterate through array summing used elements and counting them
3. Calculate and return the average as a double

Second Refinement:
1. Initialise divisor and total to zero
    1.1 Set divisor = 0
    1.2 Set total = 0

2. Iterate through array summing used elements and counting them
    2.1 Initialise for loop from index 0, run to capacity - 1, step of 1
    2.2 At each index, check if arr[i] equals UNUSED_MARKER
    2.3 If arr[i] is UNUSED_MARKER, break from loop (unused elements are at end)
    2.4 Otherwise, add arr[i] to total: total = total + arr[i]
    2.5 Increment divisor: divisor = divisor + 1
    2.6 Continue until break condition or i reaches capacity - 1

3. Calculate and return the average as a double
    3.1 If divisor equals 0, return 0.0 (avoid division by zero)
    3.2 Cast total to double and divide by divisor
    3.3 Return (double)total / divisor to caller

WF12: getMedian()

1. Count used elements using countUsedElements()
2. Dynamically allocate and populate a temporary sorted array
3. Calculate the median value
4. Free allocated memory and return median

1. Count used elements using countUsedElements()
    1.1 Call countUsedElements(arr, capacity) and store result in used
    1.2 If used equals 0, return 0.0

2. Dynamically allocate and populate a temporary sorted array
    2.1 Dynamically allocate memory: tempArr = malloc(used * sizeof(int))
    2.2 Check if allocation succeeded (tempArr != NULL)
        2.2.1 If tempArr is NULL, return 0.0
    2.3 Copy used elements from arr to tempArr
        2.3.1 Initialise for loop from i = 0 to used - 1, step of 1
        2.3.2 Set tempArr[i] = arr[i]
    2.4 Sort tempArr using bubble sort algorithm
        2.4.1 Initialise outer loop from i = 0 to used - 2, step of 1
        2.4.2 Initialise inner loop from j = 0 to used - i - 2, step of 1
        2.4.3 Bounds check to satisfy Build+Intellisense
        2.4.4 If tempArr[j] > tempArr[j+1], swap:
            2.4.4.1 temp = tempArr[j]
            2.4.4.2 tempArr[j] = tempArr[j+1]
            2.4.4.3 tempArr[j+1] = temp

3. Calculate the median value
    3.1 Calculate middle index: middle = used / 2
    3.2 Declare median as double
    3.3 If used is odd (used % 2 == 1):
        3.3.1 Set median = tempArr[middle] as double
    3.4 If used is even (used % 2 == 0):
        3.4.1 Calculate average of two middle values
        3.4.2 median = (tempArr[middle - 1] + tempArr[middle]) / 2.0

4. Free allocated memory and return the median
    4.1 Call free(tempArr) to release dynamically allocated memory
    4.2 Return median to caller

WF13: getVariance()

First Refinement:
1. Receive array and its capacity as parameters
2. Count used elements using countUsedElements
3. Calculate average of used elements
4. Calculate variance
5. Return variance

Second Refinement:
1. Receive array and its capacity as parameters

2. Count used elements
    2.1 Initialise used to countUsedElements(arr, capacity)

3. Calculate average of used elements
    3.1 Initialise sum to 0
    3.2 Iterate from index 0 to used - 1, step of 1
        3.2.1 Add arr[i] to sum
    3.3 Calculate avg = sum / used (as double)

4. Calculate Variance
    4.1 Initialise varianceSum = 0.0
    4.2 Iterate from index 0 to used - 1, step of 1
        4.2.1 Calculate difference = arr[i] - avg
        4.2.2 Add (difference * difference) to varianceSum
    4.3 Calculate variance = varianceSum / used

5. Return variance

WF14: getStandardDeviation()

First Refinement:

1. Calculate variance using getVariance()
2. Calculate and return standard deviation as square root of variance

Second Refinement:
1. Calculate variance using getVariance()
    1.1 Call getVariance(arr, capacity) and store result in variance

2. Calculate and return standard deviation as square root of variance
    2.1 Calculate standardDeviation = sqrt(variance)
    2.2 Return standardDeviation

WF15: countUsedElements()

First Refinement:
1. Initialise counter for used elements
2. Iterate through array counting used elements
3. Return the count

Second Refinement:
1. Initialise counter for used elements
    1.1 Set used = 0
2. Iterate through array counting used elements
    2.1 Initialise for loop from index 0 to capacity - 1, step of 1
    2.2 At each index, check if arr[i] = UNUSED_MARKER
    2.3 If arr[i] is UNUSED_MARKER, break from loop (unused elements are at end)
    2.4 Otherwise, increment used by 1
    2.5 Continue until break condition or i reaches capacity - 1

3. Return the count
    3.1 Return used to caller

=====================================
End File
=====================================